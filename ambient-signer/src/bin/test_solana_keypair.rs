use ambient_signer::{
    PermitEnvelopeV1, PermitDomain, ClusterType, PermitAction, 
    KeyType, ReplayMode, TimeInForce, sign_permit_ed25519, bytes_to_hex
};
use solana_program::pubkey::Pubkey;
use ed25519_dalek::{Keypair, SecretKey, PublicKey};
use std::str::FromStr;
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔑 Testing ambient-signer with real Solana keypair...\n");

    // Read the keypair from the JSON file generated by solana-keygen
    let keypair_path = "test-keypair.json";
    println!("📁 Reading keypair from: {}", keypair_path);
    
    let keypair_json = fs::read_to_string(keypair_path)
        .map_err(|e| format!("Failed to read keypair file {}: {}. Make sure you've run 'solana-keygen new --outfile test-keypair.json'", keypair_path, e))?;
    
    // Parse the JSON array of bytes
    let keypair_bytes: Vec<u8> = serde_json::from_str(&keypair_json)
        .map_err(|e| format!("Failed to parse keypair JSON: {}", e))?;
    
    if keypair_bytes.len() != 64 {
        return Err(format!("Invalid keypair length: expected 64 bytes, got {}", keypair_bytes.len()).into());
    }

    // Create Ed25519 keypair from the Solana keypair (ed25519-dalek v1 API)
    // First 32 bytes are the secret key
    let secret_key = SecretKey::from_bytes(&keypair_bytes[..32])?;
    let public_key = PublicKey::from(&secret_key);
    let keypair = Keypair { secret: secret_key, public: public_key };
    
    println!("✅ Loaded keypair successfully");
    println!("📋 Public key: {}", bytes_to_hex(&keypair.public.to_bytes()));
    println!("🔐 Secret key: {}", bytes_to_hex(&keypair.secret.to_bytes()));
    println!();

    // Create a test permit envelope for placing an order
    let envelope = PermitEnvelopeV1 {
        domain: PermitDomain {
            program_id: Pubkey::from_str("6egfvA3boGA8BLTgCzwPfKZMv3W9QS5V61Ewqa6VWq2g")?,
            cluster: ClusterType::Testnet,
            version: 1,
        },
        authorizer: Pubkey::new_from_array(keypair.public.to_bytes()),
        key_type: KeyType::Ed25519,
        action: PermitAction::Place {
            market_id: 1,
            client_id: 12345,
            side: 0, // Bid
            qty: 1000000, // 1M base units
            price: Some(50000), // $50 limit price
            tif: TimeInForce::GTC,
            reduce_only: false,
            trigger_price: None,
            trigger_type: 0,
            health_floor: None,
        },
        mode: ReplayMode::HlWindow { k: 128 },
        expires_unix: 1_800_000_000, // Future timestamp
        max_fee_quote: 1000, // Max 1000 quote units for fees
        relayer: None,
        nonce: 42,
    };

    println!("📦 Created permit envelope:");
    println!("   Market ID: 1");
    println!("   Client ID: 12345");
    println!("   Side: Bid");
    println!("   Quantity: 1,000,000 base units");
    println!("   Price: $50.00");
    println!("   Time in Force: GTC (Good Till Cancel)");
    println!("   Expires: {} (Unix timestamp)", envelope.expires_unix);
    println!();

    // Sign the permit using our ambient-signer
    let signed = sign_permit_ed25519(&envelope, &keypair)?;
    let (payload_bytes, signature) = signed.into_parts();

    println!("✅ Successfully signed permit!");
    println!();
    println!("📤 Ready to send to /exchange:");
    println!("📋 Payload length: {} bytes", payload_bytes.len());
    println!("📋 Payload (hex): {}", bytes_to_hex(&payload_bytes));
    println!();
    println!("✍️  Signature length: {} bytes", signature.len());
    println!("✍️  Signature (hex): {}", bytes_to_hex(&signature));
    println!();

    // Verify the signature to ensure it's correct
    use ed25519_dalek::{Verifier, Signature};
    let signature_obj = Signature::from_bytes(&signature)?;
    
    match keypair.public.verify(&payload_bytes, &signature_obj) {
        Ok(_) => println!("✅ Signature verification: PASSED"),
        Err(e) => println!("❌ Signature verification: FAILED - {}", e),
    }

    println!();
    println!("🎉 Test completed successfully!");
    println!("💡 This payload and signature can now be sent to the Ambient Exchange /exchange endpoint");
    println!();
    println!("📋 Summary:");
    println!("   - Read keypair from {} ✅", keypair_path);
    println!("   - Loaded keypair into ambient-signer ✅");
    println!("   - Created valid permit envelope ✅");
    println!("   - Signed with Ed25519 ✅");
    println!("   - Verified signature ✅");

    Ok(())
}